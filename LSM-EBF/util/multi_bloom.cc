// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.

#include "leveldb/filter_policy.h"
#include <stdio.h>
#include "leveldb/slice.h"
#include "util/hash.h"
#include <list>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include "leveldb/env.h"
#include "leveldb/threadpool.h"
#include "util/threadpool_imp.h"
#include "leveldb/statistics.h"
#include <unistd.h>
#define handle_error_en(en, msg) \
  do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

namespace leveldb {

namespace {
static uint32_t BloomHash(const Slice& key,int id) {
   switch(id){
        case 0:
	return Hash(key.data(), key.size(), 0xbc9f1d34);
	case 1:
	return Hash(key.data(), key.size(), 0x34f1d34b);
	case 2:
	return Hash(key.data(), key.size(), 0x251d34bc);  
	case 3:
	return Hash(key.data(), key.size(), 0x01d34bc9);  
	case 4:
	return Hash(key.data(), key.size(), 0x1934bc9f);  
	case 5:
	return Hash(key.data(), key.size(), 0x934bc9f1);  
	case 6:
	return Hash(key.data(), key.size(), 0x4bc9f193);  
	case 7:
	return Hash(key.data(), key.size(), 0x51c2578a);  
	case 8:
	return Hash(key.data(), key.size(), 0xda23562f);  
	case 9:
	return Hash(key.data(), key.size(), 0x135254f2);  
	case 10:
	return Hash(key.data(), key.size(), 0xea1e4a48);  
	case 11:
	return Hash(key.data(), key.size(), 0x567925f1);  
	default:
		handle_error_en(1, "BloomHash id error");
   }
}

class ChildBloomFilterPolicy : public FilterPolicy {
 private:
  size_t bits_per_key_;
  size_t k_;
  int id_; //begin from 0
 public:
  explicit ChildBloomFilterPolicy(int bits_per_key,int id)
      : bits_per_key_(bits_per_key) ,id_(id){
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }

  virtual const char* Name() const {
    return "leveldb.BuiltinBloomFilter2";
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (int i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i],id_);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
	 h += delta;
	 array[bitpos/8] |= (1 << (bitpos % 8));
      }
    }
  }
  
  virtual void CreateFilter(const Slice *keys,int n,std::list<std::string> &dsts) const {
	return ;
  }
 
  virtual bool KeyMayMatchFilters(const Slice& key, const std::list<leveldb::Slice>& filters) const {
	return  true;
   }
  
  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key,id_);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      h += delta;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
    }
    return true;
  }
  
  virtual int filterNums() const{
      return 1;
}
};
struct CreateFilterArg{
	  ChildBloomFilterPolicy *ch;
	  std::string *dst;
};
class MultiFilter:public FilterPolicy{
private:
	std::vector<ChildBloomFilterPolicy*> filters;
	size_t bits_per_key_;
  //	static pthread_mutex_t filter_mutexs_[10];
  //	static pthread_cond_t filter_conds_[10];
	static pthread_t pids_[16];
	static std::atomic<int> curr_completed_filter_num_;
	static int filter_num_;
        static std::atomic<bool> filled_[16];
	static const Slice *keys_;
	static int n_;
	static bool end_thread;
public:
	
	static CreateFilterArg *cfas;
	static void* CreateFilter_T(void *arg){
	    int id = *(int*)(arg);
	    delete (int *)(arg);
	    CreateFilterArg *temp_cfa = cfas+id;
	    while(true){
	      //	      pthread_mutex_lock(&filter_mutexs_[id]);
	      while(!filled_[id]&&!end_thread){
		//		pthread_cond_wait(&filter_conds_[id],&filter_mutexs_[id]);
	      }
	      //	      pthread_mutex_unlock(&filter_mutexs_[id]);
	      if(end_thread){
		break;
	      }
	      uint64_t start_micros = Env::Default()->NowMicros();
	      cfas[id].ch->CreateFilter(keys_,n_,cfas[id].dst);
	      filled_[id] = false;
	      MeasureTime(Statistics::GetStatistics().get(),Tickers::CHILD_CREATE_FILTER_TIME,Env::Default()->NowMicros() - start_micros);
	      start_micros = Env::Default()->NowMicros();
	      ++curr_completed_filter_num_;
	      MeasureTime(Statistics::GetStatistics().get(),Tickers::CHILD_FILTER_OTHER_TIME,Env::Default()->NowMicros() - start_micros);
	    }
	}
	explicit MultiFilter(int bits_per_key_per_filter[],int bits_per_key):bits_per_key_(bits_per_key){
	    int i;
	    int cpu_count =  sysconf(_SC_NPROCESSORS_CONF);
	    int base_cpu_id = 8;
	    
	    bits_per_key_per_filter_ = new size_t[16]();
	    char name_buf[24];
	    end_thread = false;
	    for(i = 0 ; bits_per_key_per_filter[i]!=0 ; i++ ){
		ChildBloomFilterPolicy* ch_filter = new ChildBloomFilterPolicy(bits_per_key_per_filter[i],i);
		filters.push_back(ch_filter);
		bits_per_key_per_filter_[i] = bits_per_key_per_filter[i];
		filled_[i]=false;
	    }
	    curr_completed_filter_num_ = 0;
	    filter_num_ = i;
	    printf("filters size:%ld\n",filters.size());
	    cfas = new CreateFilterArg[filters.size()];
	    i = 0;
	
	    for(std::vector<ChildBloomFilterPolicy*>::const_iterator iter = filters.begin() ; iter != filters.end() ; iter++){
		int *temp_id = new int(i);
		cpu_set_t cpuset;
		CPU_ZERO(&cpuset);
		CPU_SET(base_cpu_id + i, &cpuset);
		
		if(pthread_create(pids_+i,NULL,MultiFilter::CreateFilter_T,(void*)(temp_id))!=0){
		    perror("create thread ");
		}
		snprintf(name_buf, sizeof name_buf, "filter:bg%d" ,i);
		name_buf[sizeof name_buf - 1] = '\0';
		pthread_setname_np(pids_[i], name_buf);
		
		if(base_cpu_id + filters.size() < cpu_count ){
		    int s = pthread_setaffinity_np(pids_[i], sizeof(cpu_set_t), &cpuset);
		    if (s != 0){
			handle_error_en(s, "pthread_setaffinity_np");
		    }
		}
		
		cfas[i++].ch =*iter;
	    }
	    
	}
	
	virtual void CreateFilter(const Slice * keys,int n, std::string *dst) const{
	    int i = 0;
	    for(std::vector<ChildBloomFilterPolicy*>::const_iterator iter = filters.begin() ; iter != filters.end() ; iter++){
		(*iter)->CreateFilter(keys,n,dst+i);
		i++;
	    }
	}
	virtual void CreateFilter(const Slice *keys,int n,std::list<std::string> &dsts) const {
	    CreateFilterArg *cfa = cfas;
	    keys_ = keys;
	    n_ = n;
	    int i = 0;
	    uint64_t start_micros = Env::Default()->NowMicros();
	    for(auto dsts_iter = dsts.begin() ; dsts_iter != dsts.end() ; ++dsts_iter){
	        // pthread_mutex_lock(&filter_mutexs_[i]);
		cfa->dst = &(*dsts_iter);
		filled_[i] = true;
		// pthread_mutex_unlock(&filter_mutexs_[i]);
		// pthread_cond_signal(&filter_conds_[i++]);
		cfa++;
		i++;
	    }
	    MeasureTime(Statistics::GetStatistics().get(),Tickers::FILTER_LOCK_TIME,Env::Default()->NowMicros() - start_micros);
	    start_micros = Env::Default()->NowMicros();
	    while(curr_completed_filter_num_ != filter_num_);
	    MeasureTime(Statistics::GetStatistics().get(),Tickers::FILTER_WAIT_TIME,Env::Default()->NowMicros() - start_micros);
	    curr_completed_filter_num_ = 0;
	}
	virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter,int id) const{
	    return filters[id]->KeyMayMatch(key,bloom_filter);
	}
	virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const{
	    return true;
	}
	virtual bool KeyMayMatchFilters(const Slice& key, const std::list<Slice> &filter_strs) const{
	   std::vector<ChildBloomFilterPolicy*>::const_iterator filter_iter = filters.begin();
	   for(std::list<Slice>::const_iterator filter_strs_iter = filter_strs.begin() ; filter_strs_iter != filter_strs.end() ; filter_strs_iter++){
		if(!(*filter_iter)->KeyMayMatch(key,*filter_strs_iter)){
		    return false;
		}
		filter_iter++;
	    }
	    return true;
	}
	
	virtual int filterNums() const override{
	    return filters.size();
	}
	
	virtual const char* Name() const{
	    return "leveldb.multi_bloom_filter";
	}
	
	virtual ~MultiFilter(){
	    int i = 0;
	    end_thread = true;
	    for(auto iter = filters.begin() ; !filters.empty(); ){
		delete *iter;
		iter = filters.erase(iter);
		pthread_join(pids_[i++],NULL);
	    }
	    fprintf(stderr,"Multi_bloom_filter destructor is called");
	}
};



std::atomic<int>  MultiFilter::curr_completed_filter_num_ (0);
int MultiFilter::filter_num_ = 0;
// pthread_mutex_t MultiFilter::filter_mutexs_[10]={PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,PTHREAD_MUTEX_INITIALIZER,};
// pthread_cond_t MultiFilter::filter_conds_[10]={PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER,PTHREAD_COND_INITIALIZER};
std::atomic<bool>  MultiFilter::filled_[16];
pthread_t MultiFilter::pids_[16];
CreateFilterArg* MultiFilter::cfas(NULL);
int MultiFilter::n_(0);
const Slice *MultiFilter::keys_(NULL);
bool MultiFilter::end_thread(false);
} //anonymous namespace

size_t * leveldb::FilterPolicy::bits_per_key_per_filter_ = nullptr;
const FilterPolicy* NewBloomFilterPolicy(int bits_per_key_per_filter[],int bits_per_key) {
	return new MultiFilter(bits_per_key_per_filter,bits_per_key);
}
const FilterPolicy *NewBloomFilterPolicy(int *){
	return NULL;
}
const FilterPolicy *NewBloomFilterPolicy(int){
	return NULL;
}

}  // namespace leveldb
